

%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
    #include <string.h>
    #include "ast/ast.h"

    int yylex(void);
    int yyparse(void);
    void yyerror(const char *s);

    ASTNode* root;
    int error_count =0 ;
    int max_errors = 1;
    
    #define RED "\x1B[31m"
    #define RESET "x1B[0m"

    const char* token_to_str(int token);

    ASTNode** statement = NULL;

    int statement_count = 0;
    int statement_capacity = 0;

    void add_statement(ASTNode* stmt) {
        if (stmt == NULL)
            return;
        if (statement_count >= statement_capacity) {
            statement_capacity = statement_capacity ? statement_capacity * 2 : 16;
            statements = realloc(statements, sizeof(ASTNode*) * statement_capacity);
        }
        statements[statement_count++] = stmt;
    }
%}


%union
{
    double val;
    char* str;
    char* var;
    struct ASTNode* node;
    struct
    {
        struct ASTNode** args;
        int arg_count;
    } *arg_list;
}


%token <val> NUMBER
%token <var> ID
%token <str> STRING
%token <str> BOOLEAN
%token ERROR LET IN IF ELSE ELIF
%token LPAREN RPAREN SEMICOLON COMMA LBRACKET RBRACKET COLON EQUALS

%left CONCAT
%left AND
%left OR
%left NOT
%left GE GT LE LT
%left PLUS MINUS
%left MULT DIVIDE MOD
%left POWER


%type <node> expr block_expr statement
%type <node> let_in_expr conditional


%type <arg_list> block_expr_list 



%% 

program :
    input {
        if(error_count == 0)
        {
            root = create_program_node(statements, statement_count,AST_PROGRAM);
        }    
        else{ root = NULL;}
    }
;


input :
    /* empty */
    | input statement {if ($2 != NULL) add_statement($2);}
    | input error
    {
        if(++error_count >= max_errors)
        {
            YYABORT;
        }

        while(1)
        {
            int tok = yylex();
            if( tok == 0 || tok == SEMICOLON || tok == '\n') break;

        }

        yyerrok;
    }
;


statement:
    SEMICOLON                            {$$ = NULL;}
    | conditional                        {$$ = $1;}
    | block_expr                         {$$ = $1;}
    | expr SEMICOLON                     {$$ = $1;}
;


conditional :
    IF LPAREN expr RPAREN expr                      {$$ = create_conditional_node($3,$5,NULL);}
    | IF LPAREN expr RPAREN expr ELSE expr          {$$ = create_conditional_node($3,$5,$7);}
;

var_decl:
    ID COLON ID EQUALS expr       {$$ = create_assignment_node($1,$5,$3,AST_ASSIGNMENT);}
    | ID EQUALS expr              {$$ = create_assignment_node($1,$3, "" , AST_ASSIGNMENT);}
;

let_in_expr:
    LET let_definitions IN expr   {$$ = create_let_node($2->args,$2->arg_count,$4);}
;

let_definitions:
    var_decl
    {
        $$ = malloc(sizeof(*$$));
        $$-> args = malloc(sizeof(ASTNode*)*1);
        $$-> args[0]= $1;
        $$-> arg_count = 1;
    }

    |
    var_decl COMMA let_definitions
    {
        $$ = malloc(sizeof(*$$));
        $$ -> args = malloc(sizeof(ASTNode* )*($3->arg_count +1));
        $$ -> args[0] = $1;
        memcpy($$->args + 1, $3->args, sizeof(ASTNode *) * $3->arg_count);
        $$->arg_count = $3->arg_count + 1;
        free($3->args);
    }

;

block_expr:
    LBRACKET block_expr_list RBRACKET   {$$ = create_program_node($2->args, $2-> arg_count,AST_BLOCK);}
;

block_expr_list:
    statement 
    {
        $$ = malloc(sizeof(*$$));

        if($1 == NULL)
        {
            $$->args = NULL;
            $$->arg_count = 0;
        }

        else
        {
            $$->args = malloc(sizeof(ASTNode*) * 1);
            $$->args[0] = $1;
            $$->arg_count = 1;
        }
    }
    | statement block_expr_list 
    {
        $$ = malloc(sizeof(*$$));

        if($1 == NULL)
        {
            $$->args = malloc(sizeof(ASTNode*)* ($2->arg_count));
            memcpy($$->args, $2->args, sizeof(ASTNode *) * $2->arg_count);
            $$->arg_count = $2->arg_count;
            free($2->args);
        }

        else {
            $$->args = malloc(sizeof(ASTNode *) * ($2->arg_count + 1));
            $$->args[0] = $1;
            memcpy($$->args + 1, $2->args, sizeof(ASTNode *) * $2->arg_count);
            $$->arg_count = $2->arg_count + 1;
            free($2->args);
        }
    }
    | /* empty */ {
        $$ = malloc(sizeof(*$$));
        $$->args = NULL;
        $$->arg_count = 0;
    }
;

expr:
    NUMBER                        {$$ = create_num_node($1);}
    | STRING                      {$$ = create_string_node($1);}
    | BOOLEAN                     {$$ = create_boolean_node($1);}
    | block_expr                  {$$ = $1;}
    | let_in_expr                 {$$ = $1;}
    | ID                          {$$ = create_var_node($1,"",0);}
    | expr CONCAT expr            {$$ = create_op_node(OP_CONCAT,"@",$1,$3,TYPE_STRING);}
    | expr GE expr                {$$ = create_op_node(OP_GE,">=",$1,$3,TYPE_BOOLEAN);}
    | expr GT expr                {$$ = create_op_node(OP_GT,">",$1,$3,TYPE_BOOLEAN);}
    | expr LE expr                {$$ = create_op_node(OP_LE,"<=",$1,$3,TYPE_BOOLEAN);}
    | expr LT expr                {$$ = create_op_node(OP_LT,"<",$1,$3,TYPE_BOOLEAN);}
    | expr PLUS expr              {$$ = create_op_node(OP_ADD,"+",$1,$3,TYPE_NUM);}
    | expr MINUS expr             {$$ = create_op_node(OP_SUB,"-",$1,$3,TYPE_NUM);}
    | expr MULT expr              {$$ = create_op_node(OP_MULT,"*",$1,$3,TYPE_NUM);}
    | expr DIVIDE expr            {$$ = create_op_node(OP_DIV,"/",$1,$3,TYPE_NUM);}
    | expr MOD expr               {$$ = create_op_node(OP_MOD,"%",$1,$3,TYPE_NUM);}
    | expr POWER expr             {$$ = create_op_node(OP_POW,"^",$1,$3,TYPE_NUM);}
    | LPAREN expr RPAREN          {$$ = $2;}
    | var_decl                    {$$ = $1;}
    | conditional                 {$$ = $1;}
    | ERROR
    {
        yyerrok;
        YYABORT;
    }
;


%%