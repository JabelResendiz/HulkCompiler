%option c++
%option yyclass="HulkLexer"
%option noyywrap
%option nodefault

%{
#include "parser.tab.hpp"
#include <string>
#include <cstdlib>
#define YY_DECL yy::parser::symbol_type HulkLexer::yylex()
%}

%%

"print"     { return yy::parser::make_PRINT(loc); }
"if"        { return yy::parser::make_IF(loc); }
"else"      { return yy::parser::make_ELSE(loc); }
"let"       { return yy::parser::make_LET(loc); }
"in"        { return yy::parser::make_IN(loc); }

";"         { return yy::parser::make_SEMICOLON(loc); }
"("         { return yy::parser::make_LPAREN(loc); }
")"         { return yy::parser::make_RPAREN(loc); }
"{"         { return yy::parser::make_LBRACE(loc); }
"}"         { return yy::parser::make_RBRACE(loc); }
","         { return yy::parser::make_COMMA(loc); }

">="        { return yy::parser::make_GE(loc); }
"<="        { return yy::parser::make_LE(loc); }
"=="        { return yy::parser::make_EQ(loc); }
">"         { return yy::parser::make_GT(loc); }
"<"         { return yy::parser::make_LT(loc); }

\"([^"\\]|\\.)*\" {
    std::string val(yytext);
    return yy::parser::make_STRING(val, loc);
}

[0-9]+ {
    return yy::parser::make_NUMBER(std::atoi(yytext), loc);
}

[a-zA-Z_][a-zA-Z0-9_]* {
    return yy::parser::make_IDENTIFIER(std::string(yytext), loc);
}

[ \t\r\n]+  ; // Ignorar espacios

. {
    // Manejar errores léxicos explícitamente
    std::cerr << "Caracter ilegal: " << yytext << "\n";
    return yy::parser::make_ERROR(loc);
}

%%

